\subsection{Identity of typed literals}

In order to deal with predefined datatypes such as integers, dates, etc.,
  RDF introduces the notion of ``typed literals''.
For such typed literals, identity does not suffice in order to ascertain
  that the sets of object terms denote the same resources
  (definition \ref{def:indiscernibility_properties}).
The reason for this is that typed literals have special identity conditions.
Since typed literals are quite common in SW data, we elaborate on this here.
Roughly speaking, for typed literals we assume a lexical-to-value mapping
  \cite{Hayes2004}, which assigns a value to each lexical expression.
For each datatype we assume a datatype-specific identity relation
  partitioning the datatype's value space.
Identity between typed literals is then defined
  as the datatype-specific identity between the values of the literals
  under the lexical-to-value mapping.
This extension was already used to perform the computational
  experiment of section \ref{sec:experiment}.

\begin{comment}
First we assume a datatype map
  \mbox{$D : \mathcal{I} \rightarrow ICEXT(I({\small \texttt{rdfs:Datatype}}))$},
  where $ICEXT$ is the functional map from classes onto their instances.
Second, for each datatype $d$ we assume a lexical-to-value mapping
  $L2V(d)$,\cite{Hayes2004},
  %: V(d) \rightarrow LEX(d)
  which assigns a value to each lexical expression.
Finally, for each datatype $d$ we assume a datatype-specific identity relation
  $\sim_d$ partitioning the datatype's value space $V(d)$.\footnote{
    Relation $\sim_d$ poses some problems to implement correctly,
      see section \ref{sec:implementation} for details.
    }

Suppose that two objects $o_1$ and $o_2$ are both typed literals,
  with $o_1 = \pair{d_1}{x_1}$ and $o_2 = \pair{d_2}{x_2}$
  for datatype names $d_1$ and $d_2$ and value names $x_1$ and $x_2$.
Identity between $o_1$ and $o_2$ is then defined as in
  \ref{def:identity_typed_literals}.

\begin{definition}[Identity for typed literals]
\label{def:identity_typed_literals}
\begin{align}
  o_1 \approx o_1
\,\iff\,
    D(d_1) = D(d_2)
  & \; \land \; &\nonumber\\
    x_1 \in LEX(d_1)
  & \; \land \; &\nonumber\\
    x_2 \in LEX(d_2)
  & \; \land \; &\nonumber\\
    l2v(D(d_1))(x_1) \sim_d l2v(D(d_2))(x_2)\nonumber
\end{align}
\end{definition}

\noindent Notice that the datatype-specific lexical-to-value mapping
  in definition \ref{def:identity_typed_literals} is relevant for
  the identification of identity,
  since two lexical expressions may map onto the same value
  according to one datatype but onto different values
  according to another.
An example of this are the lexical expressions $0.1$ and $0.10000000009$,
  which map to the same value according to datatype
  {\small \texttt{xsd:float}}
  but to different values according to datatype
  {\small \texttt{xsd:decimal}} \cite{Goldberg1991}.

In definition \ref{def:identity_typed_literals}
  the conjuncts which state that the value names belong to
  the respective lexical spaces may seem superfluous at first.
But for ill-typed literals,
  i.e. those whose value names do not belong to the lexical space of
  the specified datatype,
  the interpretation is not determined and they are only known to denote
  some arbitrary non-literal value \cite{Hayes2004}.\footnote{
    From the practice of working with SW data, the authors can testify
    that ill-typed literals do occur and are actually quite common!}
\end{comment}

